"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractRequestHandler = void 0;
const models_1 = require("../../circuits/models");
const constants_1 = require("../constants");
const js_iden3_core_1 = require("@iden3/js-iden3-core");
const common_1 = require("./common");
const message_handler_1 = require("./message-handler");
/**
 *
 * Allows to process ContractInvokeRequest protocol message
 *
 * @beta

 * @class ContractRequestHandler
 * @implements implements IContractRequestHandler interface
 */
class ContractRequestHandler extends message_handler_1.AbstractMessageHandler {
    /**
     * Creates an instance of ContractRequestHandler.
     * @param {IPackageManager} _packerMgr - package manager to unpack message envelope
     * @param {IProofService} _proofService -  proof service to verify zk proofs
     * @param {IOnChainZKPVerifier} _zkpVerifier - zkp verifier to submit response
     *
     */
    constructor(_packerMgr, _proofService, _zkpVerifier) {
        super();
        this._packerMgr = _packerMgr;
        this._proofService = _proofService;
        this._zkpVerifier = _zkpVerifier;
        this._supportedCircuits = [
            models_1.CircuitId.AtomicQueryMTPV2OnChain,
            models_1.CircuitId.AtomicQuerySigV2OnChain,
            models_1.CircuitId.AtomicQueryV3OnChain
        ];
    }
    async handle(message, ctx) {
        switch (message.type) {
            case constants_1.PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE:
                await this.handleContractInvoke(message, ctx);
                return null;
            default:
                return super.handle(message, ctx);
        }
    }
    async handleContractInvoke(message, ctx) {
        if (message.type !== constants_1.PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE) {
            throw new Error('Invalid message type for contract invoke request');
        }
        const { senderDid: did, ethSigner, challenge } = ctx;
        if (!ctx.ethSigner) {
            throw new Error("Can't sign transaction. Provide Signer in options.");
        }
        const { chain_id } = message.body.transaction_data;
        const networkFlag = Object.keys(js_iden3_core_1.ChainIds).find((key) => js_iden3_core_1.ChainIds[key] === chain_id);
        if (!networkFlag) {
            throw new Error(`Invalid chain id ${chain_id}`);
        }
        const verifierDid = message.from ? js_iden3_core_1.DID.parse(message.from) : undefined;
        const zkpResponses = await (0, common_1.processZeroKnowledgeProofRequests)(did, message?.body?.scope, verifierDid, this._proofService, { ethSigner, challenge, supportedCircuits: this._supportedCircuits });
        return this._zkpVerifier.submitZKPResponse(ethSigner, message.body.transaction_data, zkpResponses);
    }
    /**
     * unpacks contract-invoke request
     * @beta
     * @param {Uint8Array} request - raw byte message
     * @returns `Promise<ContractInvokeRequest>`
     */
    async parseContractInvokeRequest(request) {
        const { unpackedMessage: message } = await this._packerMgr.unpack(request);
        const ciRequest = message;
        if (message.type !== constants_1.PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE) {
            throw new Error('Invalid media type');
        }
        ciRequest.body.scope = ciRequest.body.scope || [];
        return ciRequest;
    }
    /**
     * handle contract invoker request
     * @beta
     * @param {did} did  - sender DID
     * @param {ContractInvokeRequest} request  - contract invoke request
     * @param {ContractInvokeHandlerOptions} opts - handler options
     * @returns {Map<string, ZeroKnowledgeProofResponse>}` - map of transaction hash - ZeroKnowledgeProofResponse
     */
    async handleContractInvokeRequest(did, request, opts) {
        const ciRequest = await this.parseContractInvokeRequest(request);
        return this.handleContractInvoke(ciRequest, {
            senderDid: did,
            ethSigner: opts.ethSigner,
            challenge: opts.challenge
        });
    }
}
exports.ContractRequestHandler = ContractRequestHandler;
